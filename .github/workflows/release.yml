name: Release

on:
  push:
    tags:
      - 'v*'

jobs:
  goreleaser:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.25'

      - name: Run Goreleaser
        uses: goreleaser/goreleaser-action@v3
        with:
          version: latest
          args: release --clean
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify signatures with cosign (keyless)
        run: |
          set -euo pipefail
          echo "Verifying signatures for artifacts in dist/ with retry/backoff"
          artifacts=(dist/*)
          if [ ${#artifacts[@]} -eq 0 ]; then
            echo "No artifacts found in dist/ to verify" >&2
            exit 1
          fi

          verified=0
          for f in dist/*; do
            [ -f "$f" ] || continue
            case "$f" in *.sig) continue ;; esac

            sig="$f.sig"
            attempts=0
            success=0
            until [ $attempts -ge 5 ]; do
              if [ -f "$sig" ]; then
                echo "Found signature $sig; verifying (attempt $((attempts+1)))"
                if cosign verify-blob --keyless --signature "$sig" "$f"; then
                  echo "Verified $f"
                  success=1
                  break
                else
                  echo "Verification failed for $f (attempt $((attempts+1))). Retrying..."
                fi
              else
                echo "Signature $sig not present yet (attempt $((attempts+1))). Retrying..."
              fi
              attempts=$((attempts+1))
              sleep $((attempts * 5))
            done

            if [ $success -ne 1 ]; then
              echo "Failed to verify $f after $attempts attempts" >&2
              exit 1
            fi
            verified=$((verified+1))
          done
          echo "Successfully verified $verified artifacts"

      - name: Determine version
        id: ver
        run: |
          TAG=${GITHUB_REF#refs/tags/}
          VERSION=${TAG#v}
          echo "TAG=$TAG" >> $GITHUB_ENV
          echo "VERSION=$VERSION" >> $GITHUB_ENV

      - name: Compute checksums for Windows zips
        id: checksums
        run: |
          set -euo pipefail
          echo "Looking in dist for windows zips"
          FILE_X64=$(ls dist/*_windows_amd64.zip 2>/dev/null | head -n1 || true)
          FILE_ARM=$(ls dist/*_windows_arm64.zip 2>/dev/null | head -n1 || true)
          if [ -z "$FILE_X64" ]; then
            echo "No windows amd64 zip found in dist" >&2
            exit 1
          fi
          SHA_X64=$(sha256sum "$FILE_X64" | awk '{print $1}')
          FILE_X64_BASENAME=$(basename "$FILE_X64")
          echo "FILE_X64=$FILE_X64_BASENAME" >> $GITHUB_ENV
          echo "SHA_X64=$SHA_X64" >> $GITHUB_ENV
          if [ -n "$FILE_ARM" ]; then
            SHA_ARM=$(sha256sum "$FILE_ARM" | awk '{print $1}')
            FILE_ARM_BASENAME=$(basename "$FILE_ARM")
            echo "FILE_ARM=$FILE_ARM_BASENAME" >> $GITHUB_ENV
            echo "SHA_ARM=$SHA_ARM" >> $GITHUB_ENV
          else
            echo "FILE_ARM=" >> $GITHUB_ENV
            echo "SHA_ARM=" >> $GITHUB_ENV
          fi

      - name: Generate winget manifest
        run: |
          TAG=${{ env.TAG }}
          VERSION=${{ env.VERSION }}
          REPO=${{ github.repository }}
          FILE_X64=${{ env.FILE_X64 }}
          FILE_ARM=${{ env.FILE_ARM }}
          SHA_X64=${{ env.SHA_X64 }}
          SHA_ARM=${{ env.SHA_ARM }}
          URL_X64="https://github.com/$REPO/releases/download/$TAG/$FILE_X64"
          if [ -n "$FILE_ARM" ]; then
            URL_ARM="https://github.com/$REPO/releases/download/$TAG/$FILE_ARM"
          else
            URL_ARM=""
          fi
          echo "Generating winget manifest for $VERSION"
          pwsh ./packaging/winget/generate-winget-manifest.ps1 -Version "$VERSION" -InstallerUrlX64 "$URL_X64" -Sha256X64 "$SHA_X64" -InstallerUrlArm64 "$URL_ARM" -Sha256Arm64 "$SHA_ARM"

      - name: Commit and push winget manifest
        env:
          VERSION: ${{ env.VERSION }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          BRANCH="winget-manifest/${VERSION}"
          git checkout -b "$BRANCH"
          git add packaging/winget/PlebOne/nos/${VERSION}
          git commit -m "chore: add winget manifest for ${VERSION}" || echo "No changes to commit"
          git push --set-upstream origin "$BRANCH"

      - name: Create pull request for winget manifest
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "chore: add winget manifest for ${{ env.VERSION }}"
          title: "Add winget manifest for ${{ env.VERSION }}"
          body: |
            This PR was auto-generated by the release workflow. It contains the winget manifest
            files for version ${{ env.VERSION }} under `packaging/winget/PlebOne/nos/${{ env.VERSION }}`.
          base: main
          head: winget-manifest/${{ env.VERSION }}

      - name: Fork and create PR to microsoft/winget-pkgs (gh CLI)
        if: ${{ env.WINGET_PKS_PAT }}
        env:
          WINGET_PKS_PAT: ${{ secrets.WINGET_PKS_PAT }}
          VERSION: ${{ env.VERSION }}
          REPO: ${{ github.repository }}
          TAG: ${{ env.TAG }}
        run: |
          set -euo pipefail
          # Install gh and jq if missing
          sudo apt-get update
          sudo apt-get install -y gh jq

          echo "Authenticating gh with provided PAT"
          echo "$WINGET_PKS_PAT" | gh auth login --with-token

          # Fork and clone the upstream repo into the runner
          echo "Forking microsoft/winget-pkgs and cloning"
          gh repo fork microsoft/winget-pkgs --clone=true --remote=true

          # Determine fork owner
          FORK_OWNER=$(gh api user --jq .login)
          echo "Fork owner: $FORK_OWNER"

          cd winget-pkgs
          BRANCH="winget-pkgs-patch/${VERSION}"

          # If the branch exists on origin (fork), check it out; otherwise create it
          if git ls-remote --heads origin "$BRANCH" | grep -q "$BRANCH"; then
            echo "Branch $BRANCH exists on origin; checking out and resetting"
            git fetch origin "$BRANCH"
            git checkout -B "$BRANCH" "origin/$BRANCH"
          else
            echo "Creating branch $BRANCH"
            git checkout -b "$BRANCH"
          fi

          PUBLISHER_LOWER=$(echo "PlebOne" | tr '[:upper:]' '[:lower:]')
          DEST_DIR="manifests/p/${PUBLISHER_LOWER}/nos/${VERSION}"
          mkdir -p "$DEST_DIR"
          cp -R ../../packaging/winget/PlebOne/nos/${VERSION}/* "$DEST_DIR/"

          # Install yq for YAML validation if missing
          if ! command -v yq >/dev/null 2>&1; then
            echo "Installing yq for manifest validation"
            sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
            sudo chmod +x /usr/local/bin/yq
          fi

          # Basic manifest validation: ensure required fields exist
          echo "Validating manifest files in $DEST_DIR"
          for mf in "$DEST_DIR"/*.yaml; do
            [ -f "$mf" ] || continue
            echo "Checking $mf"
            pkgid=$(yq e '.PackageIdentifier // ""' "$mf")
            ver=$(yq e '.PackageVersion // ""' "$mf")
            installers_count=$(yq e '.Installers | length' "$mf")
            if [ -z "$pkgid" ] || [ -z "$ver" ] || [ "$installers_count" -lt 1 ]; then
              echo "Manifest validation failed for $mf: PackageIdentifier='$pkgid' PackageVersion='$ver' Installers=$installers_count" >&2
              exit 1
            fi
            echo "Validated $mf"
          done

          git add "$DEST_DIR"
          # Commit if there are changes
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Add or update winget manifest for nos ${VERSION}"
          fi

          # Push updates to the fork; force to ensure branch updates propagate
          git push --set-upstream origin "$BRANCH" --force-with-lease

          # Create PR only if one doesn't already exist
          if gh pr view --repo microsoft/winget-pkgs --head "$FORK_OWNER:$BRANCH" >/dev/null 2>&1; then
            echo "A PR from $FORK_OWNER:$BRANCH to microsoft/winget-pkgs already exists. Skipping PR creation."
          else
            echo "Creating PR to microsoft/winget-pkgs from $FORK_OWNER:$BRANCH"
            gh pr create --repo microsoft/winget-pkgs --title "Add winget manifest for nos ${VERSION}" --body "Auto-generated winget manifest for nos ${VERSION}" --head "$FORK_OWNER:$BRANCH" --base main || echo "PR creation failed or already exists"
          fi

      - name: List release artifacts for audit
        run: |
          set -euo pipefail
          echo "=== dist/ contents ==="
          if [ -d dist ]; then
            ls -la dist || true
          else
            echo "dist/ directory not found"
          fi

          echo "\n=== Signature files ==="
          if compgen -G "dist/*.sig" > /dev/null; then
            ls -la dist/*.sig || true
          else
            echo "No .sig files found in dist/"
          fi

          echo "\n=== SHA256 checksums ==="
          if [ -d dist ]; then
            for f in dist/*; do
              if [ -f "$f" ]; then
                sha256sum "$f" || true
              fi
            done
          fi

      - name: Create checksums file
        run: |
          set -euo pipefail
          mkdir -p dist
          checksums_file=dist/checksums.txt
          echo "Creating $checksums_file"
          > "$checksums_file"
          for f in dist/*; do
            # skip signature files and existing checksums file
            if [ "$f" = "$checksums_file" ] || [[ "$f" == *.sig ]]; then
              continue
            fi
            if [ -f "$f" ]; then
              sha256sum "$f" >> "$checksums_file"
            fi
          done
          echo "Checksums written to $checksums_file"

      - name: Sign checksums file with cosign (keyless)
        run: |
          set -euo pipefail
          checksums_file=dist/checksums.txt
          sig_file="$checksums_file.sig"
          if [ ! -f "$checksums_file" ]; then
            echo "$checksums_file not found" >&2
            exit 1
          fi
          echo "Signing $checksums_file with cosign (keyless) -> $sig_file"
          cosign sign-blob --keyless --output-signature "$sig_file" "$checksums_file"
          echo "Signature written to $sig_file"

      - name: Upload checksums file to GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          TAG=${GITHUB_REF#refs/tags/}
          REPO=${{ github.repository }}
          echo "Fetching release info for tag $TAG"
          # Install jq if missing
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update && sudo apt-get install -y jq
          fi
          release_json=$(curl -s -H "Authorization: token $GITHUB_TOKEN" "https://api.github.com/repos/$REPO/releases/tags/$TAG")
          upload_url=$(echo "$release_json" | jq -r .upload_url | sed -e 's/{?name,label}//')
          if [ -z "$upload_url" ] || [ "$upload_url" = "null" ]; then
            echo "Could not determine upload URL for release tag $TAG" >&2
            echo "$release_json" >&2
            exit 1
          fi
          checksums_file=dist/checksums.txt
          sig_file="$checksums_file.sig"
          if [ ! -f "$checksums_file" ]; then
            echo "$checksums_file not found" >&2
            exit 1
          fi
          echo "Uploading $checksums_file to release $TAG"
          curl --fail -s -X POST -H "Authorization: token $GITHUB_TOKEN" -H "Content-Type: application/octet-stream" --data-binary @"$checksums_file" "$upload_url?name=$(basename $checksums_file)"
          echo "Uploaded checksums to release"
          if [ -f "$sig_file" ]; then
            echo "Uploading signature $sig_file to release $TAG"
            curl --fail -s -X POST -H "Authorization: token $GITHUB_TOKEN" -H "Content-Type: application/octet-stream" --data-binary @"$sig_file" "$upload_url?name=$(basename $sig_file)"
            echo "Uploaded signature to release"
          else
            echo "Signature file $sig_file not found; skipping upload"
          fi
